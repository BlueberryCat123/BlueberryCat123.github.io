{"posts":[{"title":"Matlab史密斯圆图与LNA设计","text":"这几天需要用Matlab设计一个LNA，结果发现Matlab的史密斯圆图不太好用… 于是我决定自己整一个史密斯圆图。 电阻圆族和电抗圆族公式如下： $${(\\Gamma_{r}-\\frac{r}{1+r})}^2 + {\\Gamma_{i}}^2 = {(\\frac{1}{1+r})}^2$$ $${(\\Gamma_{r}-1)}^2 + {(\\Gamma_{i}-\\frac{1}{x})}^2 = {(\\frac{1}{x})}^2$$ 那么，可以写出代码如下： 12345678910111213141516171819202122232425262728function [] = smith() for x = -4 : 0.2 : 4 viscircles([1, 1 / x], 1 / abs(x), &quot;LineWidth&quot;, 0.1, &quot;Color&quot;, &quot;blue&quot;); xlim([-1, 1]); ylim([-1, 1]); end line([-1, 1], [0, 0], &quot;LineWidth&quot;, 0.1, &quot;Color&quot;, &quot;blue&quot;); for r = 0 : 0.2 : 5 viscircles([r / (1 + r), 0], 1 / (1 + r), &quot;LineWidth&quot;, 0.1, &quot;Color&quot;, &quot;blue&quot;); hold on; axis equal; xlim([-1, 1]); ylim([-1, 1]); end anglex={-1, -1, 1, 1}; angley={1, -1, -1, 1}; for i = 1 : 4 for theta = pi / 2 * i : pi / 1000 : pi / 2 * ( i + 1 ) x = cos(theta); y = sin(theta); x1 = cos(theta + pi / 1000); y1 = sin(theta + pi / 1000); fill([x, x1, anglex{i}], [y, y1, angley{i}], &quot;b&quot;); end endend 效果是这样的 LNA设计基于上文的史密斯圆图来表示。 具体公式比较复杂，可以去看《射频电路设计――理论与应用（第二版）》这本书📕，公式位于第九章。 代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156clear;close all;clc;% S11 A11 S21 A21 S12 A12 S22 A22 Topt_m Topt_a Fmin_db Rn/50 顺序 Parameter_demo = [0.3 30 2.5 -80 0.2 -60 0.2 -15 0.5 45 1.5 0.08];Parameter_2G = [];% 选择S参数Sel = Parameter_demo;% 指定 增益G_db = 8;G = power(10, G_db / 10);% 指定 VSWRimnVSWRimn = 1.5;Timn_abs = (VSWRimn - 1) / (VSWRimn + 1);% 指定 噪声系数F_db = 1.6; F = power(10, F_db / 10);% Rn/50Rn = Sel(12);% 最小噪声系数Fmin_db = Sel(11); Fmin = power(10, Fmin_db / 10);% opt反射系数Topt_a = ang2rad(Sel(10));Topt = Sel(9) * exp (1i * Topt_a);% 指定S参数a11 = ang2rad(Sel(2));s11 = Sel(1) * exp (1i * a11);a21 = ang2rad(Sel(4));s21 = Sel(3) * exp (1i * a21);a12 = ang2rad(Sel(6));s12 = Sel(5) * exp (1i * a12);a22 = ang2rad(Sel(8));s22 = Sel(7) * exp (1i * a22);% 史密斯圆图subplot(121);smith();% 稳定性计算delta = s11 * s22 -s12 * s21;k = (1 - power(abs(s11), 2) - power(abs(s22), 2) + power(abs(delta), 2)) / (2 * abs(s12) * abs(s21));% 最大功率增益Gmax = abs(s21) / abs(s12) * (k - sqrt(power(k, 2) - 1));Gmax_db = 10 * log10(Gmax);% 比例系数g0 = G / power(abs(s21), 2);% 功率增益圆dg0 = g0 * conj(s22 - delta * conj(s11)) / (1 + g0 * (power(abs(s22), 2) - power(abs(delta), 2)));rg0 = sqrt(1 - 2 * k * g0 * abs(s12 * s21) + power(g0, 2) * power(abs(s12 * s21), 2)) / abs(1 + g0 * (power(abs(s22), 2) - power(abs(delta), 2)));% 转换dgs = ((1 - s22 * dg0) * conj((s11 - delta * dg0)) - power(rg0, 2) * conj(delta) * s22) / (power(abs(1 - s22 * dg0), 2) - power(rg0, 2) * power(abs(s22), 2));rgs = rg0 * abs(s12 * s21) / abs(power(abs(1 - s22 * dg0), 2) - power(rg0, 2) * power(abs(s22), 2));viscircles([real(dgs), imag(dgs)], rgs, &quot;LineWidth&quot;, 2, &quot;Color&quot;, &quot;red&quot;);% 噪声功率圆Qk = power(abs(1 + Topt), 2) * (F - Fmin) / (4 * Rn);df = Topt / (1 + Qk);rf = sqrt((1 - power(abs(Topt), 2)) * Qk + power(Qk, 2)) / (1 + Qk);viscircles([real(df), imag(df)], rf, &quot;LineWidth&quot;, 2, &quot;Color&quot;, &quot;green&quot;);% 噪声optscatter(real(Topt), imag(Topt), &quot;red&quot;);% 扫描取优min_F = inf;VSWRomn_target = inf;for degree = 1:360 Ts = dgs + rgs * exp (1i * ang2rad(degree)); Tl = (s11 - conj(Ts)) / (delta - s22 * conj(Ts)); Tout = s22 + s12 * s21 * Ts / (1 - s11 * Ts); Tomn = (conj(Tout) - Tl) / (1 - Tl * Tout); VSWRomn = (1 + abs(Tomn)) / (1 - abs(Tomn)); if(abs(Ts - df) &lt; rf &amp;&amp; VSWRomn &lt; VSWRomn_target) scan_F = Fmin + 4 * Rn * power(abs(Ts - Topt), 2) / ((1 - power(abs(Ts), 2)) * power(abs(1 + Topt), 2)); if(scan_F &lt; min_F) min_F = scan_F; Ts_final = Ts; Tl_final = Tl; end scatter(real(Ts), imag(Ts), &quot;yellow&quot;); endendscatter(real(Ts_final), imag(Ts_final), &quot;red&quot;);% 下面进行VSWR的优化Tin = s11 + (s21 * s12 * Tl_final) / (1 - s22 * Tl_final);dv_imn = (1 - power(Timn_abs, 2)) * conj(Tin) / (1 - power(Timn_abs * abs(Ts), 2));rv_imn = (1 - power(abs(Tin), 2)) * Timn_abs / (1 - power(Timn_abs * abs(Ts), 2));viscircles([real(dv_imn), imag(dv_imn)], rv_imn, &quot;LineWidth&quot;, 2, &quot;Color&quot;, &quot;cyan&quot;);VSWRomn_list = zeros(360, 1);for degree = 1:360 Ts = dv_imn + rv_imn * exp (1i * ang2rad(degree)); Tout = s22 + s12 * s21 * Ts / (1 - s11 * Ts); Tomn = (conj(Tout) - Tl_final) / (1 - Tl_final * Tout); VSWRomn_list(degree) = (1 + abs(Tomn)) / (1 - abs(Tomn));endsubplot(122);grid on;xlim([1, 360]);ylim([1, inf]);hold on;% 画出不同角度的VSWR，然后选择一个角度plot(1:360, VSWRomn_list, &quot;Color&quot;, &quot;blue&quot;);line([1, 360], [VSWRimn, VSWRimn], &quot;Color&quot;, &quot;red&quot;, &quot;LineStyle&quot;, &quot;--&quot;);prompt = &quot;选择角度：&quot;;degree = input(prompt);Ts_final = dv_imn + rv_imn * exp (1i * ang2rad(degree));Tout = s22 + s12 * s21 * Ts_final / (1 - s11 * Ts_final);% Gt值计算Gt = (1 - power(abs(Tl_final), 2)) * power(abs(s21), 2) * (1 - power(abs(Ts_final), 2)) / (power(abs(1 - Ts_final * Tin), 2) * power(abs(1 - s22 * Tl_final), 2));Gt_db = 10 * log10(Gt);% 噪声系数F_final = Fmin + 4 * Rn * power(abs(Ts_final - Topt), 2) / ((1 - power(abs(Ts_final), 2)) * power(abs(1 + Topt), 2));F_final_db = 10 * log10(F_final);% 输出fprintf(&quot;Ts: %f∠%f°\\nTout: %f∠%f°\\n&quot;, abs(Ts_final), getAngle(Ts_final), abs(Tout), getAngle(Tout));fprintf(&quot;Gt(dB): %f\\nF(dB): %f\\nVSWRomn: %f\\n&quot;, Gt_db, F_final_db, VSWRomn_list(degree)); 该代码应配合下面的函数使用。 123function [rad] = ang2rad(ang) rad = ang / 360 * 2 * pi;end 123function [ang] = getAngle(z) ang = angle(z) / 2 / pi * 360;end 运行结果如下： 左图中红圈就是对于$\\Gamma_{S}$的等增益圆，绿圈则是等噪声圆。 绿圈中的红点是$\\Gamma_{opt}$。 左图下方一大片黄点是满足参数要求（增益、噪声）的点，红色的则是噪声系数最小的点。 获得噪声系数最小的点后，进行驻波比优化。通过给定IMN的驻波比，画出图中蓝色的等驻波比圆。扫描该圆，计算驻波比，画出右图。 右图中实线是OMN的驻波比，需要找到一个比较小的点；虚线是IMN的驻波比。 将找到的OMN对应的角度输入Matlab，即可得到输出。","link":"https://blueberrycat123.github.io/2023/05/27/Matlab%E5%8F%B2%E5%AF%86%E6%96%AF%E5%9C%86%E5%9B%BE%E4%B8%8ELNA%E8%AE%BE%E8%AE%A1/"},{"title":"My First Post","text":"经典图片 这个博客打算用来写一些我觉得有价值的东西，或者记录一些有意思的事情。之前的那个旧网站就留在那里吧，不少人对于ChatGPT这个功能还挺喜欢的。 旧网站链接：BlueberryCat.site 这次我使用了Hexo框架，终于不用自己手写HTML或者CSS了… 之前VUE版的项目和Quasar的项目写的也差不多了。但是感觉这种框架的工作量太大了，作为个人博客啥的实在是有些杀鸡用牛刀了。 顺便一提，现在在post内可以写数学公式了！ $$E = mc^2$$","link":"https://blueberrycat123.github.io/2023/05/27/My-First-Post/"},{"title":"RTMP、HLS与HTTP-FLV","text":"最近，有个项目需要使用OpenCV输出的图片推流到网页。这个东西相当的麻烦，主要是我以前从来没做过相关的东西。 这种需求相关的协议有三种： 协议 优点 缺点 RTSP 超低时延，可以达到毫秒级。 技术实现复杂。 RTMP 低时延，秒级；适应性好。 需要Flash支持，目前不流行。 HLS 动态切换码流；苹果安卓都可以用。 高时延，不适合做视频直播，一般用作点播或者音频广播。 首先排除RTSP，这东西几乎没啥可用文档。 RTMP RTMP是应用层协议，全称Real Time Message Protocol。Adobe开发的协议，部署起来很简单，但是已经停止开发了。 协议细节请点击这里查看。 不过除非你要基于TCP/IP写一个RMTP应用，一般是不用太深入了解，只需要知道它能分组传输消息就行。 RTMP是基于FLV文件格式的协议，这种文件格式专门为流媒体设计，可以用一种持续不断“流”的方式进行传输。播放器拿到这种格式的分包后，会根据其中信息进行重排序，进而得到一个完整的媒体文件。 HLS 不同于RTMP，HLS同是应用层协议，但是其是基于HTTP协议传输的。 这个协议最大的特点就是把一个完整的媒体文件切分成许多短媒体，然后在一个m3u8文件里控制这些短媒体文件的读取。 本质上是在传输这些切分好的文件。 下面是CCTV1频道的语音主m3u8文件，它指出了各种带宽应使用的源。 依据奈氏准则，理想低通信道的最高码元传输速率 = 2W Baud 12345678910#EXTM3U#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1800000,RESOLUTION=1280x720/cctvwbcd/cdrmcctv1_1/index.m3u8?BR=td#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=1350000,RESOLUTION=1024x576/cctvwbcd/cdrmcctv1_1/index.m3u8?BR=ud#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=900000,RESOLUTION=854x480/cctvwbcd/cdrmcctv1_1/index.m3u8?BR=hd#EXT-X-STREAM-INF:PROGRAM-ID=1,BANDWIDTH=600000,RESOLUTION=640x360/cctvwbcd/cdrmcctv1_1/index.m3u8?BR=md 下面则是从主m3u8找到的对应的子m3u8，它控制着每个短流媒体的读取。 在直播场景下，子m3u8不能有#EXT-X-ENDLIST标志，否则浏览器会停止请求子m3u8，进而导致播放列表无法更新，直播断流。 123456789101112131415161718#EXTM3U#EXT-X-VERSION:3#EXT-X-ALLOW-CACHE:NO#EXT-X-TARGETDURATION:12#EXT-X-MEDIA-SEQUENCE:1684822835#EXTINF:12.000000,#EXT-X-PROGRAM-DATE-TIME:2023-05-29T16:33:34+0800cdrmcctv1_1_1800-1684822835.ts#EXTINF:12.000000,#EXT-X-PROGRAM-DATE-TIME:2023-05-29T16:33:46+0800cdrmcctv1_1_1800-1684822836.ts#EXTINF:12.000000,#EXT-X-PROGRAM-DATE-TIME:2023-05-29T16:33:58+0800cdrmcctv1_1_1800-1684822837.ts#EXTINF:12.000000,#EXT-X-PROGRAM-DATE-TIME:2023-05-29T16:34:10+0800cdrmcctv1_1_1800-1684822838.ts 实践证明，HLS大多数时间都是用作点播，直播支持较差。 上面两个协议使用起来体验都不太好。 前者要求浏览器拥有Flash支持，几乎只能使用本地的VLC媒体播放器；后者则是要求对媒体进行切分，时间粒度较大，延时较高，而且直播支持不太完善。 所以，对于当下的直播，大多数使用的是HTTP-FLV。 HTTP-FLV 这种方式结合了RTMP和HLS的优点，使用HTTP来分发FLV流。 在浏览器的网络监视器中，可以看到一个持续不断的文件请求，类型是x-flv。 实际上，我们也可以用HTTPS来传输。 服务器配置 Nginx有专门的包对RTMP和HTTP-FLV做了支持（HLS一般访问文件即可），所以使用起来很简单。 首先需要从GitHub上拉取nginx-http-flv-module。这个模块已经支持了RTMP，所以不用另外加上别的模块。 解压后执行下面的命令进行编译安装： 123./configure --add-module=/tmp/nginx-http-flv-module --with-http_ssl_modulemakemake install 安完后默认在/usr/local/nginx下，可执行文件在上述路径的sbin下。 我的网站有SSL证书，所以配置了HTTPS。参考配置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263worker_processes 1;events { worker_connections 1024;} # 添加RTMP服务rtmp { server { listen 1935; application live { live on; } }}# 添加http-flv服务http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server { listen 443; server_name blueberrycat.site; ssl on; #ssl证书的pem文件路径 ssl_certificate /root/blueberrycat.site_nginx/blueberrycat.site_bundle.pem; #ssl证书的key文件路径 ssl_certificate_key /root/blueberrycat.site_nginx/blueberrycat.site.key; location / { root html; index index.html index.htm; } error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } location /live { flv_live on; chunked_transfer_encoding on; # 添加一些控制访问的头 add_header 'Access-Control-Allow-Credentials' 'true'; add_header 'Access-Control-Allow-Origin' '*'; add_header Access-Control-Allow-Headers X-Requested-With; add_header Access-Control-Allow-Methods GET,POST,OPTIONS; add_header 'Cache-Control' 'no-cache'; } } server { listen 80; server_name blueberrycat.site; # 将请求转成https rewrite ^(.*)$ https://$host$1 permanent; }} 推流 推流地址可以是 1https://blueberrycat.site/live?port=1935&amp;app=live&amp;stream={ 自定义的推流名 } 也可以是 1rtmp://blueberrycat.site/live/{ 自定义的推流名 } 取决于你想用哪种协议。 回到项目，Python与OpenCV推流代码如下： 12345678910111213141516171819202122232425262728293031323334353637import cv2import subprocess as spcap = cv2.VideoCapture(0)fps = cap.get(cv2.CAP_PROP_FPS)size = (int(cap.get(cv2.CAP_PROP_FRAME_WIDTH)), int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT)))sizeStr = str(size[0]) + 'x' + str(size[1])command = ['ffmpeg', '-y', # 覆盖确认 '-f', 'rawvideo', # 指定输入格式 '-pix_fmt', 'bgr24', # 格式 '-s', sizeStr, # 大小 '-r', str(fps), # FPS '-i', '-', # 输入-管道 '-c:v', 'libx264', # 264编码 '-pix_fmt', 'yuv420p', # 420p '-preset', 'ultrafast', # 高速处理 '-f', 'flv', # flv输出 '-b', '1000000', # 码率 'rtmp://blueberrycat.site/live/123'] # 推流地址pipe = sp.Popen(command, stdin=sp.PIPE, shell=False, bufsize=10**8) # 建立管道，这步很重要while cap.isOpened(): ret, frame = cap.read() if ret == True: cv2.imshow('frame', frame) if cv2.waitKey(1) &amp; 0xFF == ord('q'): break else: break pipe.stdin.write(frame.tobytes()) # 推流 为了测试这些协议，我在旧网站上做了大量的测试，结果直接把主机弄炸了，旧网站直接下线。 默哀。 尽量别在Ubuntu用yum装g++ 网页端 建议使用hlv.js，Bilibili开发（难以置信）。 官方说明 An HTML5 Flash Video (FLV) Player written in pure JavaScript without Flash. LONG LIVE FLV! 😂 使用示例 1234567891011121314&lt;script src=&quot;flv.min.js&quot;&gt;&lt;/script&gt;&lt;video id=&quot;videoElement&quot;&gt;&lt;/video&gt;&lt;script&gt; if (flvjs.isSupported()) { var videoElement = document.getElementById('videoElement'); var flvPlayer = flvjs.createPlayer({ type: 'flv', url: '{ 这里换成自己的推流 }' }); flvPlayer.attachMediaElement(videoElement); flvPlayer.load(); flvPlayer.play(); }&lt;/script&gt; 最终效果是这样的","link":"https://blueberrycat123.github.io/2023/05/29/RTMP%E3%80%81HLS%E4%B8%8EHTTP-FLV/"},{"title":"天线方向图","text":"之前做实验，老师要求用Origin画天线的方向图，结果我实在是整不到破解版，就自己用Matalb整了一个。 代码就不放了，毕竟确实也比较简单。 效果还是不错的。 这里半功率主瓣也标出来了，可以用鼠标点一下上下的点来计算主瓣宽度。","link":"https://blueberrycat123.github.io/2023/05/28/%E5%A4%A9%E7%BA%BF%E6%96%B9%E5%90%91%E5%9B%BE/"},{"title":"用Unity开发的坦克小游戏","text":"用Unity的免费素材包做了个小游戏。 看起来是不是很有意思？点击这里下载 在这个游戏里，坦克会分为四个队伍，互相对战！ 每个队还会拥有一座 “强力” 的防御塔，向靠近的敌人喷射怒火！ 和AI队友通力协作，打败其他的AI！ 联机游戏真是写不动了 死亡后有观战视角，能看AI互锤。 没有退出键，需要ALT+F4退出，致敬刀剑神域！","link":"https://blueberrycat123.github.io/2023/05/27/%E7%94%A8Unity%E5%BC%80%E5%8F%91%E7%9A%84%E5%9D%A6%E5%85%8B%E5%B0%8F%E6%B8%B8%E6%88%8F/"},{"title":"崩坏：星穹铁道 伤害计算器","text":"闲来无事，用QT搓了一个伤害计算器。 大概长这样👇 左侧是角色的基础面板数据、Buff效果和怪物属性，选择性输入这三大部分就可以在右侧拿到当前升级词条的价值和伤害数值。 词条期望是由B站用户 @LucasCheung299 提供的计算式。 伤害公式来自 这篇文章 点击这里即可下载！ 其实本来是做了个Matlab App的，但看起来大家都没有Matlab，只能弄个可执行文件分发了…😔","link":"https://blueberrycat123.github.io/2023/05/27/%E5%B4%A9%E5%9D%8F%EF%BC%9A%E6%98%9F%E7%A9%B9%E9%93%81%E9%81%93-%E4%BC%A4%E5%AE%B3%E8%AE%A1%E7%AE%97%E5%99%A8/"},{"title":"矩形平面阵阵因子计算","text":"项目需求，需要算一下平面阵的阵因子。 本文计算阵因子使用的是比较简单的方法，利用直线阵的公式计算平面阵。 实际上还可以使用向量进行分析，更加的泛用。 均匀直线阵的阵因子公式如下： $$ f(\\psi) = \\frac{sin(\\frac{N}{2}\\psi)}{sin(\\frac{1}{2}\\psi)} $$ $$ \\psi = kdcos\\delta + \\xi $$ $d$是阵元间距，$\\delta$是观察方向和阵轴的夹角，$\\xi$是阵元的相移。 对于平面阵，我们可以把它分解为X方向和Y方向的两个均匀直线阵。由乘法原理可知： $$ f(\\theta, \\varphi) = f_{1}(\\theta, \\varphi) \\times f_{2x} (\\theta, \\varphi) \\times f_{2y}(\\theta, \\varphi) $$ 计算时只需要换算一下阵轴夹角即可： $$ cos\\delta_{x} = sin\\theta sin\\varphi $$ $$ cos\\delta_{y} = sin\\theta cos\\varphi $$ 代码如下 123456789101112131415161718192021222324252627282930313233343536clear;close all;clc;% 指定频率freq = 1.5e6;c = physconst('lightspeed');lambda = c / freq;k = 2 * pi / lambda;% 指定平面阵参数dx = 1 / 4 * lambda;dy = 1 / 4 * lambda;nx = 3;ny = 3;pdx = 0;pdy = 0;theta = meshgrid(eps : pi / 180 : pi);phi = meshgrid(eps : 2 * pi / 180 : 2 * pi)';f2x = sin(nx / 2 * (k * dx * (sin(theta) .* cos(phi)) + pdx)) ./ sin(1 / 2 * (k * dx * (sin(theta) .* cos(phi)) + pdx));f2y = sin(ny / 2 * (k * dy * (sin(theta) .* sin(phi)) + pdy)) ./ sin(1 / 2 * (k * dy * (sin(theta) .* sin(phi)) + pdy));f = f2x .* f2y;f = abs(f);[x, y, z] = sph2cart(phi, pi / 2 - theta, f);mesh(x, y, z);title('平面阵方向图');xlabel('x'), ylabel('y'), zlabel('z');axis equal; 由于Matlab不会去计算极限，所以计算时会出现NaN，无法计算对数坐标。 网格上的小缺口就是NaN的位置，公式计算几乎无法消除这个问题。 之后我会尝试使用向量计算，这样就可以规避掉上面的问题。","link":"https://blueberrycat123.github.io/2023/05/31/%E7%9F%A9%E5%BD%A2%E5%B9%B3%E9%9D%A2%E9%98%B5%E9%98%B5%E5%9B%A0%E5%AD%90%E8%AE%A1%E7%AE%97/"},{"title":"多径衰落仿真","text":"做实验时写出来的代码，感觉会用的上，记录一下。 task1 - 计算多径衰落的时域分布。 task2 - 计算多径衰落的空间分布。 task3 - 用BPSK调制，对比有无衰落的误码率。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135clear;close all;clc;L = 1:1000;N = 16;v = 40 / 3.6;f_c = 800e6;C = physconst('lightspeed');R = 9600;ramda = C / f_c;T = 1 / R;FDT = v * f_c / C * T;% --- Task 1theta = zeros([N, 1]);for n = 1 : N if(n == 1) theta(n) = rand() * 2 * pi / 16; else theta(n) = theta(n - 1) + rand() * 2 * pi / 16; endendphi = rand([N, 1]) * 2 * pi;alpha = 2 * pi * FDT * cos(theta);k = 1 : 1000;Fk = exp(1j * ((alpha * k) + phi));Fk = sum(Fk, 1) / sqrt(N);Fk = 20 * log10(abs(Fk));figure(1);plot(Fk);% --- Task 2X = 1 : 100;Y = 1 : 100;F = zeros(100, 100);for x = X for y = Y F(x, y) = abs(sum(exp(1j * ((y / 100 * cos(theta) - x / 100 * sin(theta)) * 2 * pi / ramda + phi))) / sqrt(N)); endendfigure(2);mesh(F);% --- Task 3snr_in_db = 1 : 10;M = 1e6;a = zeros([M, 1]);for i = 1 : M temp=rand; if(temp&gt;0.5) a(i) = 1; else a(i) = 0; endendsignal = zeros([M, 1]);for i = 1 : M signal(i) = 2 * a(i) - 1;endpf = zeros([length(snr_in_db), 1]);for i = 1 : length(snr_in_db) numoferr = 0; snr = power(10, snr_in_db(i) / 10); wk = gngauss(0, 1, M) / sqrt(snr); k = 1 : M; Fk = exp(1j * ((alpha * k) + phi)); Fk = sum(Fk, 1) / sqrt(N); rk = signal .* Fk' + wk; dk = rk .* conj(Fk'); for k = 1 : M if (dk(k) &gt; 0) a_cd = 1; else a_cd = 0; end if (a_cd ~= a(k)) numoferr = numoferr + 1; end end pf(i) = numoferr / M;endpa = zeros([length(snr_in_db), 1]);for i = 1 : length(snr_in_db) numoferr = 0; snr = power(10, snr_in_db(i) / 10); wk = gngauss(0, 1, M) / sqrt(snr); rk = signal + wk; dk = rk; for k = 1 : M if (dk(k) &gt; 0) a_cd = 1; else a_cd = 0; end if (a_cd ~= a(k)) numoferr = numoferr + 1; end end pa(i) = numoferr / M;endfigure(3);semilogy(snr_in_db, [pf, pa]);grid on; 高斯白噪声函数 1234567891011121314151617function [gsrv] = gngauss(m, sgma, n) if nargin == 0 m = 0; sgma = 1; elseif nargin == 1 sgma = m; m = 0; end u = rand([n, 1]); z = sgma * (sqrt(2 * log(1 ./ (1 - u)))); u = rand([n, 1]); gsrv1 = m + z .* cos(2 * pi .* u); gsrv2 = m + z .* sin(2 * pi .* u); gsrv = gsrv1 + 1j * gsrv2; gsrv = gsrv / sqrt(2);end 运行结果","link":"https://blueberrycat123.github.io/2023/06/04/%E5%A4%9A%E5%BE%84%E8%A1%B0%E8%90%BD%E4%BB%BF%E7%9C%9F/"}],"tags":[{"name":"Matlab","slug":"Matlab","link":"https://blueberrycat123.github.io/tags/Matlab/"},{"name":"LNA","slug":"LNA","link":"https://blueberrycat123.github.io/tags/LNA/"},{"name":"RTMP","slug":"RTMP","link":"https://blueberrycat123.github.io/tags/RTMP/"},{"name":"HLS","slug":"HLS","link":"https://blueberrycat123.github.io/tags/HLS/"},{"name":"HTTP-FLV","slug":"HTTP-FLV","link":"https://blueberrycat123.github.io/tags/HTTP-FLV/"},{"name":"Unity","slug":"Unity","link":"https://blueberrycat123.github.io/tags/Unity/"},{"name":"Game","slug":"Game","link":"https://blueberrycat123.github.io/tags/Game/"},{"name":"星穹铁道","slug":"星穹铁道","link":"https://blueberrycat123.github.io/tags/%E6%98%9F%E7%A9%B9%E9%93%81%E9%81%93/"},{"name":"QT","slug":"QT","link":"https://blueberrycat123.github.io/tags/QT/"},{"name":"矩形平面阵","slug":"矩形平面阵","link":"https://blueberrycat123.github.io/tags/%E7%9F%A9%E5%BD%A2%E5%B9%B3%E9%9D%A2%E9%98%B5/"},{"name":"阵因子","slug":"阵因子","link":"https://blueberrycat123.github.io/tags/%E9%98%B5%E5%9B%A0%E5%AD%90/"},{"name":"多径衰落","slug":"多径衰落","link":"https://blueberrycat123.github.io/tags/%E5%A4%9A%E5%BE%84%E8%A1%B0%E8%90%BD/"}],"categories":[{"name":"Codes","slug":"Codes","link":"https://blueberrycat123.github.io/categories/Codes/"},{"name":"Daily","slug":"Daily","link":"https://blueberrycat123.github.io/categories/Daily/"}],"pages":[]}